<html>
	<meta charset="UTF-8"/>
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
	<meta http-equiv="Pragma" content="no-cache" />
	<meta http-equiv="Expires" content="0" />
	<head>
		<title>Christian Afonso - Violins against Aliens</title>
		<link rel="stylesheet" href="styles.css" type="text/css"/>
		<script src="sequencer/sound.js"></script>
		<script src="sequencer/sequencer.js"></script>
		<script>
			var segmentsFolder = 'segments/';
			var videoFolder = 'video/';
			var segments = {
				intro_action_master: {
					name: 'intro_action_master',
					file: 'AWAC_intro_action_MASTERTRACK.ogg',
					layers: [
						{ name: 'base', segment: 'intro_action_BASE' },
						{ name: 'intense', segment: 'intro_action_INTENSE' }
					],
					next: 'loop_action_master',
					outro: 'outro_master'
				},
				intro_action_BASE: {
					name: 'intro_action_BASE',
					file: 'AWAC_intro_action_BASE.ogg',
					next: 'loop_action_master',
					outro: 'outro_master'
				},
				intro_action_INTENSE: {
					name: 'intro_action_INTENSE',
					file: 'AWAC_intro_action_INTENSE.ogg',
					next: 'loop_action_master',
					outro: 'outro_master'
				},
				loop_action_master: {
					name: 'loop_action_master',
					file: 'AWAC_loop_action_MASTERTRACK.ogg',
					layers: [
						{ name: 'base', segment: 'loop_action_BASE' },
						{ name: 'intense', segment: 'loop_action_INTENSE' }
					],
					next: 'loop_action_master',
					outro: 'outro_master',
					stinger: 'stinger_gliss_master',
					tempo: 138,
					beat: '4/4',
					bars: [
						{ number: 1, offset: 0 },
						{ number: 2, offset: 1.739 },
						{ number: 3, offset: 3.478 },
						{ number: 4, offset: 5.217 },
						{ number: 5, offset: 6.956 },
						{ number: 6, offset: 8.695 },
						{ number: 7, offset: 10.434 },
						{ number: 8, offset: 12.173 },
						{ number: 9, offset: 13.913 },
						{ number: 10, offset: 15.652 },
						{ number: 11, offset: 17.391 },
						{ number: 12, offset: 19.130, beat: '5/4' },
						{ number: 13, offset: 21.304 },
						{ number: 14, offset: 23.043 },
						{ number: 15, offset: 24.782 },
						{ number: 16, offset: 26.521 },
						{ number: 17, offset: 28.260 },
						{ number: 18, offset: 30 },
						{ number: 19, offset: 31.739 },
						{ number: 20, offset: 33.478 },
						{ number: 21, offset: 35.217 },
						{ number: 22, offset: 36.956 },
						{ number: 23, offset: 38.695 },
						{ number: 24, offset: 40.434, beat: '5/4' },
						{ number: 25, offset: 42.608, beat: '3/4' },
						{ number: 26, offset: 43.913, beat: '3/4' },
						{ number: 27, offset: 45.217, beat: '3/4' },
						{ number: 28, offset: 46.521, beat: '3/4' },
						{ number: 29, offset: 47.826, beat: '3/4' },
						{ number: 30, offset: 49.130, beat: '3/4' },
						{ number: 31, offset: 50.434, beat: '4/4' },
						{ number: 32, offset: 52.173, beat: '4/4' }
					]
				},
				loop_action_BASE: {
					name: 'loop_action_BASE',
					file: 'AWAC_loop_action_BASE.ogg',
					next: 'loop_action_master',
					outro: 'outro_master'
				},
				loop_action_INTENSE: {
					name: 'loop_action_INTENSE',
					file: 'AWAC_loop_action_INTENSE.ogg',
					next: 'loop_action_master',
					outro: 'outro_master'
				},

				intro_dramatic_master: {
					name: 'intro_dramatic_master',
					file: 'AWAC_intro_dramatic_MASTERTRACK.ogg',
					layers: [
						{ name: 'base', segment: 'intro_dramatic_BASE' },
						{ name: 'intense', segment: 'intro_dramatic_INTENSE' }
					],
					next: 'segment_dramatic_master',
					outro: 'outro_master',
					stinger: 'stinger_dramatic_master'
					// stinger: 'stinger_gliss_fast_master'
				},
				intro_dramatic_BASE: {
					name: 'intro_dramatic_BASE',
					file: 'AWAC_intro_dramatic_BASE.ogg',
					next: 'loop_action_master',
					outro: 'outro_master'
				},
				intro_dramatic_INTENSE: {
					name: 'intro_dramatic_INTENSE',
					file: 'AWAC_intro_dramatic_INTENSE.ogg',
					next: 'loop_action_master',
					outro: 'outro_master'
				},
				segment_dramatic_master: {
					name: 'segment_dramatic_master',
					file: 'AWAC_segment_dramatic_MASTERTRACK.ogg',
					layers: [
						{ name: 'base', segment: 'segment_dramatic_BASE' },
						{ name: 'intense', segment: 'segment_dramatic_INTENSE' }
					],
					// stinger: 'stinger_dramatic_master',
					next: 'loop_action_master',
					outro: 'outro_master',
					tempo: 138,
					beat: '4/4',
					bars: [
						{ number: 1, offset: 0 },
						{ number: 2, offset: 1.739 },
						{ number: 3, offset: 3.478 },
						{ number: 4, offset: 5.217 },
						{ number: 5, offset: 6.956 },
						{ number: 6, offset: 8.695 },
						{ number: 7, offset: 10.434 },
						{ number: 8, offset: 12.173 },
						{ number: 9, offset: 13.913 },
						{ number: 10, offset: 15.652 },
						{ number: 11, offset: 17.391 },
						{ number: 12, offset: 19.130 },
						{ number: 13, offset: 20.869 },
						{ number: 14, offset: 22.608 },
						{ number: 15, offset: 24.347 },
						{ number: 16, offset: 26.086 }
					]
				},
				segment_dramatic_BASE: {
					name: 'segment_dramatic_BASE',
					file: 'AWAC_segment_dramatic_BASE.ogg',
					next: 'loop_action_master',
					outro: 'outro_master'
				},
				segment_dramatic_INTENSE: {
					name: 'segment_dramatic_INTENSE',
					file: 'AWAC_segment_dramatic_INTENSE.ogg',
					next: 'loop_action_master',
					outro: 'outro_master'
				},
				
				outro_master: {
					name: 'outro_master',
					file: 'AWAC_outro_MASTERTRACK.ogg',
					next: '',
					outro: '',
					stinger: 'stinger_outro_master'
				},

				// stingers
				stinger_gliss_master: {
					name: 'stinger_gliss_master',
					file: 'AWAC_stinger_gliss_MASTERTRACK.ogg',
					next: '',
					outro: '',
					type: 'stinger',
					startOffset: 0.869
				},
				stinger_gliss_fast_master: {
					name: 'stinger_gliss_fast_master',
					file: 'AWAC_stinger_gliss_fast_MASTERTRACK.ogg',
					next: '',
					outro: '',
					type: 'stinger',
					startOffset: 0.434
				},
				stinger_dramatic_master: {
					name: 'stinger_dramatic_master',
					file: 'AWAC_stinger_dramatic_MASTERTRACK.ogg',
					next: '',
					outro: '',
					type: 'stinger',
					startOffset: 0.869
				},
				stinger_outro_master: {
					name: 'stinger_outro_master',
					file: 'AWAC_stinger_outro_MASTERTRACK.ogg',
					next: '',
					outro: '',
					type: 'stinger',
					startOffset: 0.869
				}
			};
			
			// Page
			var logDiv;
			var filterDiv;
			var graphDiv;
			
			// Audio
			var context;
			var source;
			var source_INTENSE;
			var gain_INTENSE;
			var stingerSource;
			
			// Intensity Slider
			var intensitySlider;
			
			// Synced video
			var video;
			
			// Sounds
			var soundBank;
			
			// Sequencer
			var startSegment = 'intro_action_master';
			var currentSegment = null;
			var nextQueuedSegmentName = null; // set this to override currentSegment's next
			var queuedSegmentNode = null;
			
			var isPlaying = false;
			var lastSegmentStartTime = 0; // when last a segment was started
			var currentSegmentEndTime = 0; // when the current segment naturally ends
			var nextSegmentEndTime = 0; // when we want to jump out of current segment (may be earlier than above)
			
			var intensity = 1; // default

			// debug logging: sound loading, queueing etc.
			var loggingEnabled = false;

			window.addEventListener('click', init, false); // audio can only start on interaction
			window.addEventListener('touchstart', init, false); // audio can only start on interaction
			window.addEventListener('resize', onResize);
			window.addEventListener('resume', _ => { if(context) context.resume(); })
			
			// setup AudioContext
			function init()
			{
				window.removeEventListener('click', arguments.callee);
				window.removeEventListener('touchstart', arguments.callee);

				logDiv = document.getElementById("log");
				let logSBDiv = document.getElementById("logSB");
				if(loggingEnabled) logSBDiv.style.visibility = "visible";

				intensitySlider = document.getElementById("intensity");
				if(intensitySlider) {
					intensitySlider.oninput = function() {
						intensity = intensitySlider.value / 100; // percent to ratio
						if(gain_INTENSE) {
							gain_INTENSE.gain.setValueAtTime(Math.min(intensity, 1), context.currentTime); // safeguard against invalid values
						}
						// console.log("intensity: " + intensity); // DEBUG
					};
				}

				video = document.getElementById("video");

				// onResize();

				log("Init...", true);
				try {
					window.AudioContext = window.AudioContext || window.webkitAudioContext || window.MozAudioContext;
					context = new AudioContext();
					context.onstatechange = function() { console.log("Audio context state changed: " + context.state); }
				} catch(e) {
					alert('No audio support');
				}
				
				if(context.state != "running") {
					context.resume().then(_ => { loadSegments(); });
				} else {
					loadSegments();
				}
			}

			function onResize()
			{
				// setCanvasSize('100%', '100%') // ?
			}

			function setCanvasSize(width, height)
			{
				let canvas = document.getElementById("canvas");
				canvas.style.width = width;
				canvas.style.height = height;
				canvas.width = canvas.offsetWidth;
				canvas.height = canvas.offsetHeight;
			}
			
			function loadSegments()
			{
				log("Loading segments...");

				// HACK detect ogg capability
				let audio = document.createElement('audio');
				let canPlayOgg = audio.canPlayType("audio/ogg");

				let files = [];
				Object.keys(segments).forEach((key) => {
					let file = segments[key].file;
					if(!canPlayOgg) {
						console.log("Can't play ogg, try mp3...");
						segments[key].file = "mp3/"+ file.replace(".ogg", ".mp3");
					}
					files.push({
						name: segments[key].name,
						file: segments[key].file
					});
				});

				soundBank = new SoundBank(context);  // logSB
				soundBank.loadSounds(files, segmentsFolder, onSoundsLoaded, onError);
			}
			
			function generateNameFromPath(path) {
				return path.replace(/^.*\//g, "").replace(/\.[^.]*$/g, "");
			}

			function onError(e)
			{
				log("Error!");
				console.log(e);
			}
			
			function onSoundsLoaded(trigger)
			{
				//log("onSoundsLoaded: (triggered by "+trigger+")</br>");
				log("Sounds loaded.");
				playbackReady();
			}
			
			function playbackReady()
			{
				log("Playback ready!");
				
				// create buttons
				var buttons = document.getElementById("buttons");
				if(!buttons) {
					buttons = document.createElement("div");
					buttons.id = "buttons";
					logDiv.parentElement.insertBefore(buttons, logDiv.parentElement.children[0]);
				}
				
				if(buttons) {
					var playButton = document.createElement("button");
					playButton.id = "playButton";
					playButton.className = "button";
					playButton.innerHTML = "Start";
					playButton.onclick = start;
					
					var trigger_dramatic = document.createElement("button");
					trigger_dramatic.id = "trigger_dramatic";
					trigger_dramatic.innerHTML = "Trigger dramatic event";
					trigger_dramatic.onclick = () => { triggerOnNextBar("intro_dramatic_master"); };
					disableButton("trigger_dramatic", true);
					trigger_dramatic.disabled = true; // activate on play
					
					var stopButton = document.createElement("button");
					stopButton.id = "stopButton";
					stopButton.innerHTML = "Trigger Stop";
					stopButton.onclick = () => {
						disableButton("stopButton", true);
						disableButton("trigger_dramatic", true);
						if(currentSegment && currentSegment.outro) {
							triggerOnNextBar(currentSegment.outro);
						} else {
							stop();
						}
					};
					stopButton.disabled = true; // activate on play
					
					// TODO if this works, move it out into own page!
//					var sequencerButton = document.createElement("button");
//					sequencerButton.id = "sequencer";
//					sequencerButton.innerHTML = "Sequencer Test";
//					sequencerButton.onclick = () => {
//						startSequencer();
//					};
					
					buttons.appendChild(playButton);
					buttons.appendChild(trigger_dramatic);
					buttons.appendChild(stopButton);
//					buttons.appendChild(sequencerButton);
				}
				
				let sliderDiv = document.getElementById('sliderDiv');
				if(sliderDiv) sliderDiv.style.visibility = "visible";

				graphDiv = document.createElement("div");
				logDiv.parentElement.insertBefore(graphDiv, logDiv)
			}
			
			function start()
			{
				playSegment(startSegment);
				
				disableButton("playButton", true);
				disableButton("stopButton", false);
				
				// TEST live display
				// TODO convert to setTimeout? Always set timeout one beat before end of bar to queue next one?
				window.requestAnimationFrame(onAnimationFrame);
			}
			let lastBar = "";
			function onAnimationFrame(timestamp)
			{
				if(!currentSegment) {
					// TODO clear?
					return;
				}

				let duration = (currentSegmentEndTime - lastSegmentStartTime).toFixed(2);
				let progress = (context.currentTime - lastSegmentStartTime).toFixed(2);
				let percentage = progress / duration; // technically not percentage...

				let progressInfo = "";
				if(isPlaying) progressInfo = " (" + progress + " / " + duration + ")";
				let segmentInfo = "current Segment: " + currentSegment.name + progressInfo + "<br/>";
				// if(currentSegment.bars) {
				// 	let currentBar = findCurrentBar(currentSegment, context.currentTime);
				// 	if(currentBar != lastBar) console.log("currentBar: "+currentBar);
				// 	// if(currentBar) segmentInfo += "current bar: " + currentBar.number + "<br/>";
				//   lastBar = currentBar;
				// }
				
				if(isPlaying) logDiv.innerHTML = segmentInfo;

				// TEST draw visualization
				let canvas = document.getElementById("canvas");
				let ctx = canvas.getContext("2d");
				
				// some defaults
				let margin = 10;
				let nodeWidth = 300;
				let nodeHeight = 50;
				let offset = 50;

				// size for centering
				if(currentSegment["next"] || nextQueuedSegmentName) {
					setCanvasSize(2*nodeWidth + offset + 2*margin);
				} else {
					setCanvasSize(nodeWidth + 2*margin);
				}

				clearCanvas(ctx);
				if(isPlaying) {
					// current
					drawSegment(ctx, currentSegment, percentage, margin, margin, nodeWidth, nodeHeight);

					// next?
					if(currentSegment["next"]) {
						drawArrow(ctx, margin + nodeWidth, margin + 0.5*nodeHeight, margin + nodeWidth + offset, margin + 0.5*nodeHeight, nextQueuedSegmentName ? "#AAAAAA" : "#FFFFFF", nextQueuedSegmentName);
						drawSegment(ctx, getNextSegment(currentSegment), -1, margin + nodeWidth + offset, margin, nodeWidth, nodeHeight, true, true);
					}

					// queued trigger?
					if(nextQueuedSegmentName) {
						drawArrow(ctx, margin + nodeWidth, margin + 0.5*nodeHeight, margin + nodeWidth + offset - 2, margin + 1.6*nodeHeight, "#FFFFFF");
						drawSegment(ctx, getSegmentForName(nextQueuedSegmentName), -1, margin + nodeWidth + offset, margin + 1.1*nodeHeight, nodeWidth, nodeHeight, true, true, true);
					}
				}

				// queue next frame call
				if(isPlaying) window.requestAnimationFrame(onAnimationFrame);
			}

			function clearCanvas(ctx)
			{
				ctx.fillStyle = "#003F00";
				ctx.fillRect(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);
			}

			// TODO make only as wide/high as name/contents require?
			function drawSegment(ctx, segment, percentage, x, y, w, h, enabled, active, flashing)
			{
				if(!segment) {
					console.log("ERROR: Can't draw undefined segment!");
					return;
				}

				// defaults
				if(!x) x = 0;
				if(!y) y = 0;
				if(!w) w = 400;
				if(!h) h = 50;

				// colors
				let color_bg = "#AAAAAA"
				let color_foreground = "#007F00"
				
				if(segment == currentSegment) { // active?
					color_bg = "#FFFFFF";
					color_foreground = "#009F00";
				}
				
				// background
				ctx.fillStyle = color_bg;
				ctx.roundRect(x, y, w, h, 10, true);
				
				if(flashing) {
					let flashValue = 127*(Math.sin(context.currentTime * 5) + 1);
					flashValue = parseInt(flashValue.toFixed(0)).toString(16);
					while(flashValue.length < 2) flashValue = "0" + flashValue;
					let color_flashing = "#00FF00" + flashValue;
					
					ctx.lineWidth = 2;
					ctx.strokeStyle = color_flashing;
					ctx.roundRect(x, y, w, h, 10, false);
				}

				// foreground
				ctx.strokeStyle = color_foreground;
				ctx.fillStyle = color_foreground;

				// cursor
				if(percentage != -1) {
					ctx.lineWidth = 2;
					ctx.beginPath();
					ctx.moveTo(x + percentage * w, y);
					ctx.lineTo(x + percentage * w, y + h);
					ctx.stroke();
				}
				
				// show name
				ctx.font = "12pt Orbitron";
				ctx.fillText(segment.name.replace("_master", ""), x + 10, y + (h * 0.4));
				
				/*
				// DEBUG quarters
				ctx.strokeStyle = "#777777";
				ctx.lineWidth = 2;
				for (let i = 0; i < 4; i++) {
					ctx.beginPath();
					ctx.moveTo(i * 0.25 * w, 0); // HACK magic number
					ctx.lineTo(i * 0.25 * w, h); // HACK magic numbers
					ctx.stroke();
				}

				// DEBUG show percentage
				ctx.font = "20px Orbitron";
				ctx.fillText((percentage * 100).toFixed(0) + "%", 10, h * 0.8);
				*/
			}

			function drawArrow(ctx, x1, y1, x2, y2, color, nohead)
			{
				ctx.strokeStyle = color;
				ctx.fillStyle = color; // for head
				
				// line
				ctx.lineWidth = 2;
				ctx.beginPath();
				ctx.moveTo(x1, y1);
				let middleX = x1 + (x2-x1)/2;
				ctx.bezierCurveTo(middleX, y1, middleX, y2, x2 - (nohead ? 0 : 10), y2);
				// ctx.lineTo(x2 - 10, y2);
				ctx.stroke();
				
				// head?
				if(!nohead) {
					ctx.lineWidth = 1;
					ctx.beginPath();
					ctx.moveTo(x2, y2);
					ctx.lineTo(x2 - 10, y2 - 5);
					ctx.lineTo(x2 - 10, y2 + 5);
					ctx.lineTo(x2, y2);
					ctx.fill();
					ctx.stroke();
				}
			}
			
			function findNextBar(segment, time)
			{
				if(segment != currentSegment) {
					console.log("ERROR: findCurrentBar only works for currentSegment!");
					return null;
				};

				if(segment.bars) {
					let nextBar = null;
					for(let i=0; i < segment.bars.length; i++) // assumes chrono order
					{
						let bar = segment.bars[i];

						console.log("time: " + time + " - checking bar: " + bar.number); 
						let barStart = lastSegmentStartTime + bar.offset;
						console.log("  (start: " + barStart + ")");
						if(time < barStart) {
							console.log("Found next bar!");
							nextBar = bar;
							return nextBar;
						}
					}
					return null;
				} else return null;
			}

			// TODO comp. ineffective - replace with simple next-links when not jumping around?
			function findCurrentBar(segment, time)
			{
				if(segment != currentSegment) {
					console.log("ERROR: findCurrentBar only works for currentSegment!");
					return null;
				};

				if(segment.bars) {
					let currentBar = null;
					for(let i=0; i < segment.bars.length; i++)
					{
						let bar = segment.bars[i];

						//console.log("time: " + time + " - checking bar: " + bar.number); 
						let barStart = lastSegmentStartTime + bar.offset;
						let barDuration = getBarDuration(segment, bar);
						let barEnd = barStart + barDuration;
						//console.log("  (start: " + barStart + ", end: " + barEnd + ")");
						if(time > barStart && time < barEnd) {
							//console.log("Found current bar!");
							currentBar = bar;
							return currentBar;
						}
					}
					return null;
				} else return null;
			}

			function getBarDuration(segment, bar)
			{
				if(segment != currentSegment) {
					console.log("ERROR: findCurrentBar only works for currentSegment!");
					return 0;
				};
				
				let tempo = segment.tempo;
				let beats = parseBeats(segment.beat);
				if(bar.beat) beats = parseBeats(bar.beat);
				if(bar.tempo) tempo = bar.tempo;
				
				// TODO consider denominator
				return beats * (60/tempo);
			}

			function parseBeats(beat)
			{
				return beat.substring(0, beat.indexOf('/'));
			}

			// set safeTime to -1 to detect from stinger, 0 to not have at all, >0 to force
			function triggerOnNextBar(segment, safeTime=-1) {
				nextQueuedSegmentName = segment;
				let nextQueuedSegment = getSegmentForName(nextQueuedSegmentName);
				if(nextQueuedSegment) {
					console.log("nextQueuedSegment: "+nextQueuedSegment.name);

					if(safeTime == -1 && nextQueuedSegment.stinger) {
						let stingerSegment = getSegmentForName(nextQueuedSegment.stinger);
						if(stingerSegment) {
							safeTime = stingerSegment.startOffset;
						}
					}
					console.log("safeTime: " + safeTime);

					if(currentSegment.bars) {
						let nextBar = findNextBar(currentSegment, context.currentTime + safeTime);
						console.log("nextBar: "+JSON.stringify(nextBar));
						
						if(nextBar) {
							nextSegmentEndTime = lastSegmentStartTime + nextBar.offset;
							let timeToSwitch = nextSegmentEndTime - context.currentTime;
							console.log("switching in " + timeToSwitch + "...");
							
							source.stop(nextSegmentEndTime);
							if(source_INTENSE) source_INTENSE.stop(nextSegmentEndTime);
						}
					}
					
					if(nextQueuedSegment.stinger) {
						if(nextSegmentEndTime - context.currentTime > safeTime) {
							playStinger(getSegmentForName(nextQueuedSegmentName).stinger, nextSegmentEndTime);
						}
					}
				}
			}

			let queuedStingers = [];
			function removeQueuedStingersAfter(time = 0)
			{
				for (let i=0; i < queuedStingers.length; i++) {
					let stinger = queuedStingers[i];
					if(stinger.source && stinger.startTime > time) {
						console.log("Stopping stinger " + stinger.name + " (" + (i + 1) + "/" + queuedStingers.length + ")");
						stinger.source.stop();
					}
				}
				queuedStingers = [];
			}

			// NOTE if stinger startOffset is longer than time to next segment,
			//      it should only trigger one segment later... this is checked
			//      in triggerOnNextBar
			function playStinger(segmentName, time)
			{
				// remove previous queued ones
				removeQueuedStingersAfter(context.currentTime); // any that have not yet started

				let stingerSegment = getSegmentForName(segmentName);
				if(!stingerSegment) {
					log("ERROR: Stinger segment not found: " + segmentName);
					return;
				}
				let soundElement = soundBank.getSound(stingerSegment.name);
				if(!soundElement) {
					log("ERROR: No soundElement found for name: " + segmentName + "");
					return;
				}
				
				// --------
				
				stingerSource = context.createBufferSource();
				stingerSource.buffer = soundElement.buffer;
				logSB("Created stinger source:"+stingerSource.buffer);

				stingerSource.connect(context.destination);
				
				if(!nextSegmentEndTime) nextSegmentEndTime = 0;
				logSB("nextSegmentEndTime:" + nextSegmentEndTime + ", stingerSegment.startOffset:" + stingerSegment.startOffset);
				
				let startTime = (time ? time : nextSegmentEndTime) - stingerSegment.startOffset;
				stingerSource.start(startTime);
				queuedStingers.push({ name: segmentName, source: stingerSource, startTime: startTime });
			}
			
			function playSegment(segmentName, offset)
			{
				currentSegment = getSegmentForName(segmentName);
				if(!currentSegment) {
					log("ERROR: No segment found for name: " + segmentName + "");
					return;
				}
				let soundElement = soundBank.getSound(currentSegment.name);
				let soundElement_INTENSE = null;
				// --------
				
				// TEST layers
				if(currentSegment.layers) {
					let base = currentSegment.layers.find(layer => layer.name === "base");
					let intense = currentSegment.layers.find(layer => layer.name === "intense");
					if(base && intense) {
						console.log(intense.name + ": " + intense.segment);
						soundElement = soundBank.getSound(base.segment);
						soundElement_INTENSE = soundBank.getSound(intense.segment);
					}
				}

				if(!soundElement) {
					log("ERROR: No soundElement found for name: " + segmentName + "");
					return;
				}
				
				// -----------
				
				if(!offset) offset = 0;
				
				logSB("Play " + currentSegment.name + " in " + offset + "...");
				
				// TODO create new source each time? overlap?
				// TODO store logical duration so we can determine at which time position the next segment should be queued?
				source = context.createBufferSource();
				source.buffer = soundElement.buffer;
				logSB("Created buffer source node:<br/>&nbsp;&nbsp;"+source.buffer+"");
				
				// TODO handle pre-entry segments?
				source.onended = function() {
					playNextSegment();
				};
				
				source.connect(context.destination);
				
				source.start(offset); // TODO: able to unqueue it if not yet started? just call stop!
				isPlaying = true;
				
				// LAYERS
				if(soundElement_INTENSE) {
					source_INTENSE = context.createBufferSource();
					source_INTENSE.buffer = soundElement_INTENSE.buffer;
					
					if(!gain_INTENSE) {
						gain_INTENSE = context.createGain();
					}
					source_INTENSE.connect(gain_INTENSE);
					gain_INTENSE.connect(context.destination);
					gain_INTENSE.gain.setValueAtTime(intensity, context.currentTime);

					source_INTENSE.start(offset);
				}

				// store
				lastSegmentStartTime = context.currentTime + offset;
				nextSegmentEndTime = currentSegmentEndTime = context.currentTime + offset + source.buffer.duration;
				console.log("lastSegmentStartTime: " + lastSegmentStartTime);
				console.log("nextSegmentEndTime: " + nextSegmentEndTime);
				
				showTime();
				
				// Stinger for next? HAS TO BE AFTER nextSegmentTime setting!
				var nextSegment = getNextSegment(currentSegment);
				if(nextSegment && nextSegment.stinger) {
					// TODO is not cancelled when triggering another stinger, why?
					playStinger(nextSegment.stinger, nextSegmentEndTime);
				}
				
				// Handle button states special cases
				if(["intro_dramatic_master", "segment_dramatic_master", "outro_master"].indexOf(currentSegment.name) > -1) {
					trigger_dramatic.disabled = true;
					//stopButton.disabled = true;
				} else {
					trigger_dramatic.disabled = false;
					//stopButton.disabled = false;
				}

				// WIP synced video
				if(video) {
					if(currentSegment.video) {
						video.src = videoFolder + currentSegment.video;
						video.load();
						video.play(); // TODO wait for load finish? preload in separate "buffer" tag and swap?
						video.style.visibility = 'visible';
					} else {
						video.pause();
						video.style.visibility = 'hidden';
					}
				}
			}
			
			function showTime()
			{
				if(!isPlaying) return;
				
				logSB("currentTime: " + context.currentTime + "</br>");
				//setTimeout(showTime, 0)
			}
			
			function queueSegment(segmentName)
			{
				if(currentSegmentNode) {
					queuedSegmentNode = getSegmentForName(segmentName);
					if(queuedSegmentNode) {
						playSegment(queuedSegmentNode.name, offset);
					}
				}
			}
			
			function clearQueue()
			{
				if(queuedSegmentNode) {
					queuedSegmentNode.onended = null;
					queuedSegmentNode.stop();
				}
			}
			
			// onended-handler, plays nextQueuedSegmentName immediately
			function playNextSegment()
			{
				if(nextQueuedSegmentName) {
					playSegment(nextQueuedSegmentName);
					nextQueuedSegmentName = null;
				} else if(currentSegment) {
					var nextSegment = getNextSegment(currentSegment);
					if(nextSegment && nextSegment != '') {
						playSegment(nextSegment.name);
					} else {
						stop();
					}
				} else {
					stop();
				}
			}
			
			function playOutro()
			{
				 if(currentSegment) {
					var nextSegment = getOutro(currentSegment);
					if(nextSegment) {
						playSegment(nextSegment.name);
					} else {
						stop();
					}
				} else {
					stop();
				}
			}
			
			function stop()
			{
				log("Stop.");
				
				if(source) {
					source.onended = null;
					source.stop();
				}
				
				if(video) video.pause();

				clearQueue();
				
				isPlaying = false;

				log("no segment playing", true);
				
				disableButton("playButton", false);
				disableButton("trigger_dramatic", true);
			}
		
			function disableButton(name, disabled)
			{
				let button = document.getElementById(name);
				if(button) button.disabled = disabled;
			}

			function log(text, clear)
			{
				if(!logDiv) return;

				if(clear) logDiv.innerHTML = '';
				logDiv.innerHTML += (text.replace(/ /g, '&nbsp;') + "<br/>");
			}

			function logSB(text, clear) {
				if(!loggingEnabled) return; // TEMP DEBUG, hangs up app
				if(clear) document.getElementById("logSB").innerHTML = "";
				document.getElementById("logSB").innerHTML += (text.replace(/ /g, '&nbsp;') + "<br/>");
			}
			
			// Flow control
			
			function getSegmentForName(segmentName)
			{
				if(segments[segmentName]) {
					return segments[segmentName];
				} else {
					return null;
				}
			}
			
			function getNextSegment(currentSegment)
			{
				if(currentSegment["next"]) {
					return segments[currentSegment["next"]];
				} else {
					return null;
				}
			}
			
			function getOutro(currentSegment)
			{
				if(currentSegment["outro"]) {
					return segments[currentSegment["outro"]];
				} else {
					return null;
				}
			}
			
			// TEST SEQUENCER - uses same SoundBank as before
			function startSequencer()
			{
				let sequencer = new Sequencer(context, log);
				
				// first test track: all sounds in sequence
				let track = sequencer.createTrack(0);
				let position = 0;
				Object.keys(soundBank.soundElements).forEach(name => {
					let seqEl = track.addElement(soundBank.getSound(name), position);
					log("Add sound "+name+" at position "+position);
					position += seqEl.duration;
				});

				sequencer.play(0);
			}

			// Util
			CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r, filled) {
				if (w < 2 * r) r = w / 2;
				if (h < 2 * r) r = h / 2;
				this.beginPath();
				this.moveTo(x+r, y);
				this.arcTo(x+w, y,   x+w, y+h, r);
				this.arcTo(x+w, y+h, x,   y+h, r);
				this.arcTo(x,   y+h, x,   y,   r);
				this.arcTo(x,   y,   x+w, y,   r);
				this.closePath();
				if(filled) this.fill();
				this.stroke();
				return this;
			}
		</script>
	</head>
	<body>
		<div id="background">
			<div id="title">
				<h1><big>"Violins against Aliens"</big></h1>
				<h2>(Entry for Austin Wintory's <b>Aliens: Fireteam Elite</b> Contest)</h2>
				<h3>Music by Christian Afonso<br/>based on a motif by Austin Wintory</h3>
			</div>
			<div id="content">
				<div id="left">
					<div id="sliderDiv">
						<div id="sliderLabel">
							<p>Intensity:</p>
						</div>
						<div class="slidecontainer">
							<input type="range" min="0" max="100" value="100" class="slider" id="intensity">
						</div>
					</div>
					<div id="log">
						<div align="center"><font color="#bbff00">Click to init audio</font></div>
					</div>
					<div id="canvasDiv">
						<canvas id="canvas"></canvas>
					</div>
				</div>
				<div id="right">
					<div id="videoWindow">
						<video id="videoDISABLED">
							<!-- <source src="TODO from segment" type="video/mp4"/> -->
						</video>
						<!-- TODO score image? -->
					</div>
				</div>
			</div>
			<div id="logSB" onclick="logSB('', true);" title="click to clear">
			</div>
			<div id="copyright">
				<div>© 2021 Christian Afonso</div>
				<div id="mail">chr.afonso@gmail.com</div>
			</div>
		</div>
	<body>
</html>
